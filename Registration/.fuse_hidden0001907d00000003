#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Wed Feb  7 13:39:07 2018

@author: felix
"""

def read_volume_img(lsmfile):
    
    from pylsm import lsmreader
    
    imageFile = lsmreader.Lsmimage(lsmfile)
    imageFile.open()
    
#    print imageFile.header['Image']
    xLen = imageFile.header['Image'][0]['CZ LSM info']['Dimension X']
    yLen = imageFile.header['Image'][0]['CZ LSM info']['Dimension Y']
    zLen = imageFile.header['Image'][0]['CZ LSM info']['Dimension Z']

#    print xLen
    
    frames = np.zeros((yLen, xLen, zLen),dtype='uint16')

    for zPos in range(zLen):
    
#        data = np.flipud(imageFile.get_image(stack=zPos))
        data = imageFile.get_image(stack=zPos).T
        
#        print data.shape
#        print imageFile.get_image(stack=zPos).shape
        
#        plt.figure()
#        plt.imshow(imageFile.get_image(stack=zPos))
        
        frames[:,:,zPos] = data.copy()

#    imageFile.close()

    return frames

def downsample_stack(vidstack, scale=1./2):

    from skimage.transform import rescale
    imgs = []

    for im in vidstack:
        imgs.append(rescale(im, scale=scale, mode='reflect'))
        
    return np.array(imgs)
    
    
    
# wrap around the dipy API for performing rigid body alignments.
def align_volume_stacks(img1,img2,scales=[4,2,1], iters=[10000, 1000, 100], sigmas=[4.0,1.0,0.0], nbins=32):
    
    from dipy.viz import regtools
    from dipy.data.fetcher import fetch_syn_data, read_syn_data
    from dipy.align.imaffine import (transform_centers_of_mass,
                                     AffineMap,
                                     MutualInformationMetric,
                                     AffineRegistration)
    from dipy.align.transforms import (TranslationTransform3D,
                                       RigidTransform3D,
                                       AffineTransform3D)

    # initialise grid2world. 
    grid2world = np.zeros((4,4))
    grid2world[0,0] = 1
    grid2world[1,1] = 1
    grid2world[2,2] = 1
    grid2world[3,3] = 1

    static_grid2world = grid2world.copy()
    moving_grid2world = grid2world.copy()

    # first do translation correction. 
    
    #==============================================================================
    #   First do a translation correction
    #==============================================================================
    print 'step1: matching centres'
    c_of_mass = transform_centers_of_mass(img1, static_grid2world,
                                          img2, moving_grid2world)

    nbins = 32
    sampling_prop = None
    metric = MutualInformationMetric(nbins, sampling_prop)
    level_iters = iters
    sigmas = sigmas
    factors = scales
    affreg = AffineRegistration(metric=metric,
                                level_iters=level_iters,
                                sigmas=sigmas,
                                factors=factors)
    print 'step2: matching translation'
    transform = TranslationTransform3D()
    params0 = None
    starting_affine = c_of_mass.affine 
    translation = affreg.optimize(img1, img2, transform, params0,
                                  static_grid2world, moving_grid2world,
                                  starting_affine=starting_affine)

    print 'step3: refining for rotation.'
    transform = RigidTransform3D()
    params0 = None
    starting_affine = translation.affine
    rigid = affreg.optimize(img1, img2, transform, params0,
                            static_grid2world, moving_grid2world,
                            starting_affine=starting_affine)
    
    # apply the final learnt transformation. 
    transformed = rigid.transform(img2)
    
    regtools.overlay_slices(img1, transformed, None, 0,
                        "Static", "Moving", "resampled_0.png")
    regtools.overlay_slices(img1, transformed, None, 1,
                            "Static", "Moving", "resampled_1.png")
    regtools.overlay_slices(img1, transformed, None, 2,
                            "Static", "Moving", "resampled_2.png")

    return transformed, rigid.affine

    
    
def load_dataset_tif(infolder, ext='.tif',keysplit='.'):
    
    import os 
    
    f = os.listdir(infolder)
    
    files = []
    
    for ff in f:
        if ext in ff:
            print ff
            frame_No = int((ff.split(ext)[0]).split('_')[1])
            files.append([frame_No, os.path.join(infolder, ff)])
            
    files = sorted(files, key=lambda x: x[0])
    
    return np.hstack([ff[1] for ff in files])
    
        
    
def register_3d_stack(im1,im2):
    
    fixed_image =  sitk.GetImageFromArray(im1)
    moving_image = sitk.GetImageFromArray(im2)
    
    
    # initialise the transform. 
    initial_transform = sitk.CenteredTransformInitializer(fixed_image, 
                                                          moving_image, 
                                                          sitk.Euler3DTransform(), 
                                                          sitk.CenteredTransformInitializerFilter.GEOMETRY)
    
#    moving_resampled = sitk.Resample(moving_image, fixed_image, initial_transform, sitk.sitkLinear, 0.0, moving_image.GetPixelID())
    
    registration_method = sitk.ImageRegistrationMethod()
    
    # Similarity metric settings.
    registration_method.SetMetricAsMattesMutualInformation(numberOfHistogramBins=64)
#    registration_method.SetMetricAsMeanSquares()
    registration_method.SetMetricSamplingStrategy(registration_method.REGULAR)
    registration_method.SetMetricSamplingPercentage(0.25)
    registration_method.SetInterpolator(sitk.sitkLinear)
    
    # Optimizer settings.
    registration_method.SetOptimizerAsGradientDescent(learningRate=0.5, numberOfIterations=1000, convergenceMinimumValue=1e-6, convergenceWindowSize=5)
    registration_method.SetOptimizerScalesFromPhysicalShift()
    
    # Setup for the multi-resolution framework.            
    registration_method.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])
    registration_method.SetSmoothingSigmasPerLevel(smoothingSigmas=[0,0,0])
    registration_method.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()
    
    # Don't optimize in-place, we would possibly like to run this cell multiple times.
    registration_method.SetInitialTransform(initial_transform, inPlace=False)
    
    # Connect all of the observers so that we can perform plotting during registration.
#    registration_method.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) 
    
    
    final_transform = registration_method.Execute(sitk.Cast(fixed_image, sitk.sitkFloat32), 
                                                  sitk.Cast(moving_image, sitk.sitkFloat32))
    
    moving_resampled = sitk.Resample(moving_image, fixed_image, final_transform, sitk.sitkLinear, 0.0, moving_image.GetPixelID())
    final_img = sitk.GetArrayFromImage(moving_resampled)
    
    return final_transform, final_img
    
    
def mkdir(directory):
    
    import os 
    
    if not os.path.exists(directory):
        os.makedirs(directory)
        
    return []
    

# To read the image data we use imageio
import imageio

# Pick one lib to visualize the result, matplotlib or visvis
#import visvis as plt
import matplotlib.pyplot as plt
import skimage.data as misc
import scipy.ndimage as nd
from scipy.misc import imsave
from subprocess import Popen
import numpy as np
from Utility_Functions.file_io import read_multiimg_PIL
from skimage.exposure import rescale_intensity
from skimage.filters import threshold_otsu
from skimage.morphology import binary_closing, binary_erosion, ball, binary_dilation
# Read image data
#im1 = imageio.imread('chelsea.png')
#im2 = imageio.imread('chelsea_morph1.png')

from pylsm import lsmreader
from tifffile import imread
import SimpleITK as sitk
import os 
from tqdm import tqdm 


def miller_cylindrical(r,theta,phi):

    x = theta
#    y = 5./4 * np.log(np.tan(np.pi/4.+2*phi/5.)+1e-8)
    y = 5./4 * np.arcsin(np.tan(4*phi/5.))
    
    return x, y
    
def cylindrical(r,theta,phi, theta0=0, phi0=np.pi/4.):
    """
    unzipping from any reference
    """
    y = (theta - theta0) *np.cos(phi0)
    x = (phi - phi0)
    
    return x, y
    
    
def cart2spherical(x,y,z, demean=True):
    
    if demean:
        xx = np.mean(x); yy = np.mean(y); zz = np.mean(z)
    else:
        xx = 0; yy= 0; zz = 0;
    
    dx = x - xx; dy = y-yy; dz = z - zz
    r = np.sqrt(dx**2+dy**2+dz**2)
    theta = np.arccos(dz/r)
    phi = np.arctan2(dy, dx)
    
    return r, theta, phi, np.array([xx,yy,zz])
    
def cart2spherical_seed(mean_xyz, demean=False, means=None):
    
    if demean:
        m_x = means[0]
        m_y = means[1]
        m_z = means[2]
    else:
        m_x = 0
        m_y = 0
        m_z = 0
        
    r_x = mean_xyz[:,0] - m_x
    r_y = mean_xyz[:,1] - m_y
    r_z = mean_xyz[:,2] - m_z
    
    r = np.sqrt(r_x**2 + r_y**2 + r_z**2)
    theta  = np.arccos(r_z/r)
    phi = np.arctan2(r_y, r_x)
    
    return r, theta, phi
    
    
def construct_proj_img(I, x_proj, y_proj, scale=10):
    
    scale_x = x_proj*scale ; scale_x =  scale_x - np.min(scale_x) ; scale_x = scale_x.astype(np.int)
    scale_y = y_proj*scale ; scale_y = scale_y - np.min(scale_y) ; scale_y = scale_y.astype(np.int)
    img_x = np.max(scale_x) + 1
    img_y = np.max(scale_y) + 1
    
    print img_x, img_y

    im = np.zeros((img_y, img_x))
    counts = np.zeros_like(im)
    
    for ii, intensity in enumerate(I):
        x = scale_x[ii]
        y = scale_y[ii]
        
#        im[y,x] = np.max([im[y,x], intensity])
        im[y,x] += intensity
        counts[y,x] += 1
        
        # or use max_projection. 
        
    im = im / (counts + 1e-8)
    
    return im 
    

def save_multipage_tiff(np_array, savename):
    
    """
    save numpy array of images as a multipage tiff file.... 
    
    Input:
    =====
    np_array: (n_frames, n_rows, n_cols)
    savename: filepath to save the output .tif stack. 
    
    Output:
    =====
    void function
    
    """    
    from tifffile import imsave
    
    imsave(savename, np_array.astype(np.uint8))
    
    return [] 


def update_multires_iterations():
    global metric_values, multires_iterations
    multires_iterations.append(len(metric_values))  

    
def compile_video(unwrapped_imgs, new_shape):
    
    max_row, max_col = new_shape
    new_vid_stack = np.zeros((len(unwrapped_imgs), max_row, max_col ))
    
    for ii , im in enumerate(unwrapped_imgs):
        
        m, n = im.shape
        off_m = (max_row - m) // 2
        off_n = (max_col - n) // 2
        
        new_vid_stack[ii, off_m:off_m+m, off_n:off_n+n] = im.copy()
        
    return new_vid_stack
    
    
def compute_mean_displacement3D_vectors(meantracks3D):
    
    n_spixels, n_frames, n_D = meantracks3D.shape
    
    mean_pos = np.mean(meantracks3D, axis=1)
    
    disps = (meantracks3D[:,1:] - meantracks3D[:,:-1]).astype(np.float)
    mean_disps = np.mean(disps, axis=1)
    
    
    return mean_pos, mean_disps

    
def retrieve_shell_superpixels(spixels, shell_mask, frame=0):
    
    pos = spixels[:,frame,:] # x,y,z
    
    bool_select = shell_mask[pos[:,2], pos[:,1], pos[:,0]].copy()
    
    return bool_select
    
    
    
    
from Visualisation_Tools.track_plotting import plot_tracks
import scipy.io as spio 
from skimage.exposure import rescale_intensity

"""
Load all the .mat files
"""

tif_folders = '../Data/2018-07-12_Matt_2color/repad/transformed_stack/matlab_refined_similarity'
tif_files = load_dataset_tif(tif_folders, ext='.mat')
n_files = len(tif_files)

# set up an out folder for the processed. 
out_folders = '../Data/2018-07-12_Matt_2color/repad/transformed_stack/matlab_refined_similarity_cleaned'; mkdir(out_folders)
# run the registration through the set. 
thresh = 10

for ii in range(n_files)[:]:
    
#==============================================================================
#   Step 1: load the image frame.   
#==============================================================================
    # (n_z, n_y, n_x)
#    im1 = read_multiimg_PIL(tif_files[ii]); #im1 = downsample_stack(np.squeeze(im1), scale=1./5)
    
    if ii == 0: 
        im1 = (spio.loadmat(tif_files[ii])['fixed_image']).transpose((2,0,1))
    else:
        im1 = (spio.loadmat(tif_files[ii])['movingRegistered']).transpose((2,0,1))
        
    
    """
    Segment out the entire shape. 
    """
#    thresh = threshold_otsu(im1)
#    thresh = 10
    binary_ = im1 >= thresh;
    binary_ = binary_closing(binary_, ball(7))
    
    im1_new = im1 * binary_
#    im1_new[binary_==0] = np.mean(im1[binary_==1])
    
    plt.figure()
    plt.imshow(im1_new[100])
    plt.show()

    
    savefile = os.path.join(out_folders, tif_files[ii].split('/')[-1])
    
    if ii == 0:
        spio.savemat(savefile, {'fixed_image': im1_new.transpose(1,2,0)})
    else:
        spio.savemat(savefile, {'movingRegistered': im1_new.transpose(1,2,0)})
    
#    fig, ax = plt.subplots(nrows=15,ncols=15, figsize=(20,20))
#    
#    for i in range(15):
#        for j in range(15):
#            ind = i*15 + j
#            if ind >= im1.shape[0]-1:
#                break
#            else:
#                ax[i,j].imshow(im1_new[ind], cmap='gray')
#                ax[i,j].axis('off')
#                ax[i,j].grid('off')
#                
#    fig, ax = plt.subplots(nrows=15,ncols=15, figsize=(20,20))      
#    for i in range(15):
#        for j in range(15):
#            ind = i*15 + j
#            if ind >= im1.shape[0]-1:
#                break
#            else:
#                ax[i,j].imshow(im1[ind], cmap='gray')
#                ax[i,j].axis('off')
#                ax[i,j].grid('off')
    

    







